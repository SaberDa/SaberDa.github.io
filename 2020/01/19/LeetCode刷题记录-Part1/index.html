<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <meta name="description" content="阿尔托利亚是我老婆~">
  

  
  
  
  
  
  
  <title>LeetCode刷题记录-Part1 | SaberDa的幻想乡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近在找实习刷LeetCode，所以开了这么一个系列。一是巩固自己的记忆；二是发出来我的解题思路或者我找到的认为比较好的解题思路，想让大家集思广益，分析是否有更好的解法。熟人直接微信或者qq小窗即可，不熟的见上方邮箱。这个系列估计会在我找到全职工作后才会停止更新。 我觉得刷LeetCode最大的乐趣并不在于你WA了多次后迎来AC，或者一遍AC，而是AC后去讨论区，看看其他人的代码是怎么写的？看看有">
<meta name="keywords" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题记录-Part1">
<meta property="og:url" content="https://saberda.github.io/2020/01/19/LeetCode刷题记录-Part1/index.html">
<meta property="og:site_name" content="SaberDa的幻想乡">
<meta property="og:description" content="最近在找实习刷LeetCode，所以开了这么一个系列。一是巩固自己的记忆；二是发出来我的解题思路或者我找到的认为比较好的解题思路，想让大家集思广益，分析是否有更好的解法。熟人直接微信或者qq小窗即可，不熟的见上方邮箱。这个系列估计会在我找到全职工作后才会停止更新。 我觉得刷LeetCode最大的乐趣并不在于你WA了多次后迎来AC，或者一遍AC，而是AC后去讨论区，看看其他人的代码是怎么写的？看看有">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://saberda.github.io/2020/01/19/LeetCode刷题记录-Part1/1.png">
<meta property="og:updated_time" content="2020-01-19T18:00:07.117Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode刷题记录-Part1">
<meta name="twitter:description" content="最近在找实习刷LeetCode，所以开了这么一个系列。一是巩固自己的记忆；二是发出来我的解题思路或者我找到的认为比较好的解题思路，想让大家集思广益，分析是否有更好的解法。熟人直接微信或者qq小窗即可，不熟的见上方邮箱。这个系列估计会在我找到全职工作后才会停止更新。 我觉得刷LeetCode最大的乐趣并不在于你WA了多次后迎来AC，或者一遍AC，而是AC后去讨论区，看看其他人的代码是怎么写的？看看有">
<meta name="twitter:image" content="https://saberda.github.io/2020/01/19/LeetCode刷题记录-Part1/1.png">
  
    <link rel="alternative" href="/atom.xml" title="SaberDa的幻想乡" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="SaberDa的幻想乡" rel="home">SaberDa的幻想乡</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">　　C++/ JS　　|　　呐呐呐　　|　　gli97@gwmail.gwu.edu　　|　　没有什么胜利可言  挺住就意味着一切</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">所有文章</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">主页</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/编程/">编程</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/iOS/">iOS</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/ML/">ML</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/PGM/">PGM</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/MAC/">MAC</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/御宅文化/">御宅文化</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/LIFE/">LIFE</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-LeetCode刷题记录-Part1" class="post-LeetCode刷题记录-Part1 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      LeetCode刷题记录-Part1
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://saberda.github.io/2020/01/19/LeetCode刷题记录-Part1/" data-id="ckc9h87nr001iwshz6whmx15a" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>最近在找实习刷LeetCode，所以开了这么一个系列。一是巩固自己的记忆；二是发出来我的解题思路或者我找到的认为比较好的解题思路，想让大家集思广益，分析是否有更好的解法。熟人直接微信或者qq小窗即可，不熟的见上方邮箱。这个系列估计会在我找到全职工作后才会停止更新。</p>
<p>我觉得刷LeetCode最大的乐趣并不在于你WA了多次后迎来AC，或者一遍AC，而是AC后去讨论区，看看其他人的代码是怎么写的？看看有没有和你不一样的解题思路？看看其他人是怎样优化他们的代码？看看他们的编码方式有哪些值得学习。这些才是我认为LeetCode上最有用的地方。</p>
<a id="more"></a>
<p>或许你可以说这些东西GitHub上都有，甚至会有更好的代码云云，但是举个通俗的例子来讲，这就好比你在高中时刷的题一样，只有自己付出时间努力思考，才能高效理解老师或者同学给出的解题思路。</p>
<p>我是按照题目类型去刷题的，而非题目编号顺序。好比我现在一直在刷数组类的题目，即解题使用的数据结构是基于数组而非链表的。在这个大范围下，又细分了很多小类，比如 K-Sum、双指针之类的问题。这些类型网上都有很棒的开源仓库记录，大家如果也想按照这个方法刷题的话，用搜索引擎搜索“LeetCode 分类 GitHub”即可。</p>
<p>同时，我刷题的主要语言是C++，所以下面给出一些代码示例都是C++的。</p>
<h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><p>拿C++来说，如果想不费力气的去做这方面的题，这里建议事先复习好关于vector, unordered_map, map, prioity_queue等STL提供的数据结构。用一个适合该题目的数据结构解题会节省你大量的时间。</p>
<hr>
<h2 id="K-Sum-问题"><a href="#K-Sum-问题" class="headerlink" title="K-Sum 问题"></a>K-Sum 问题</h2><p><strong>问题描述：</strong>这类题会给你一个数组和一个数字，让你计算出这个数组中的n个值的和或者积等于或者大于给出的数字。LeetCode的第一题就是该类题目。</p>
<p><strong>解题：</strong>解题前要注意下题目给出的要求，观察是否要按照升序或者降序输出，或者是否要求不能有重复的子数组，或者要求是否连续。</p>
<p>一般这种题目我首先会使用双指针来解题。如果使用双指针过于复杂，我会考虑是否使用unordered_map，即hash-map解决。</p>
<p>这里拿259题做个例子。</p>
<pre><code>Given an array of *n* integers *nums* and a *target*, find the number of index triplets `i, j, k` with `0 &lt;= i &lt; j &lt; k &lt; n` that satisfy the condition `nums[i] + nums[j] + nums[k] &lt; target`
</code></pre><p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,0,1,3], and target = 2</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: Because there are two triplets which sums are less than 2:</span><br><span class="line">             [-2,0,1]</span><br><span class="line">             [-2,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumSmaller(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(nums.size() &lt;= 2) return res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; nums.size()-2; ++i) &#123;</span><br><span class="line">            int left = i+1, right = nums.size()-1;</span><br><span class="line">            while(left &lt; right) &#123;</span><br><span class="line">                if(nums[i] + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                    res += right-left;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题是让我们从给出的数组中选出3个值，使这3个值的和小于给出的target，最后输出一共有几组符合上诉条件。像这种题目中已经暗示你需要排序的题目是很简单的，先把给出的数组排序，然后设立两个指针left和right分别指向头和尾。因为STL中的sort排序默认结果是从小到大的，所以排序后的数组越靠后的值越大。所以先固定一个值，然后分别移动left和right指针，如果和小于target，数量就+1同时左指针右移；反之右指针左移。</p>
<p>这道题是一个非常典型的使用双指针法求解K-Sum问题的例题。我们使用双指针时，这两个指针的初始位置一定要灵活，根据题意初始化位置。</p>
<hr>
<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p><strong>问题描述：</strong>这类问题一般会给你一个包含多个子数组的数组，然后针对这些数组创造的空间是否重合来对问题进行判断。</p>
<p><strong>解题：</strong>这种问题我们一般都需要对给出的数组进行排序。简单的情况可以只对原始数组进行排序，一些复杂的题解需要分别对数组的元素进行排序然后单独保存，之后再进行比较。解决这种问题时，用笔在纸上画图是最容易找出解题思路的，一般我们都需要在前一个区间的end和后一个区间的start中找交集。</p>
<p>这里我给出两道这方面的例题进行解释。</p>
<pre><code>56 Merge Intervals
Given a collection of intervals, merge all overlapping intervals.
</code></pre><p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    static bool compare(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;</span><br><span class="line">        if (a[0] == b[0]) &#123;</span><br><span class="line">            return a[1] &lt; b[1];</span><br><span class="line">        &#125;</span><br><span class="line">        return a[0] &lt; b[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), compare);</span><br><span class="line">    </span><br><span class="line">        int count = 0;</span><br><span class="line">        res.push_back(intervals[count]);</span><br><span class="line">    </span><br><span class="line">        for (int i = 1; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            if (res[count][1] &gt;= intervals[i][0]) &#123;</span><br><span class="line">                res[count][1] = max(res[count][1], intervals[i][1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个就是很明显的区间合并问题，比如在第一个example中，[1,3] 和 [2,6] 中，后一个区间的start在第一个区间内，此时就把两者合并为一个区间[1, 6]。此题的核心思路在于我们只需要比较当前区间的end是否大于等于下一个区间的start，如果是的话，则比较当前区间的end和下一个区间的end，并且取两者中的最大值作为当前区间的end，然后进行下一次循环，直到当前区间end小于下一个区间的start。</p>
<pre><code>253 Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...]` (si &lt; ei), find the minimum number of conference rooms required.
</code></pre><p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; start;</span><br><span class="line">        vector&lt;int&gt; end;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            start.push_back(intervals[i][0]);</span><br><span class="line">            end.push_back(intervals[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(start.begin(), start.end());</span><br><span class="line">        sort(end.begin(), end.end());</span><br><span class="line">        int room = 0;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            if (start[i] &lt; end[count]) &#123;</span><br><span class="line">                room++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return room;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题也是明显的区间判断问题，但是比上一道给出的例题复杂。这道题就需要我们分别对各个区间的start和end进行排序，然后通过计算比end大的start的数量给出最终答案。</p>
<p><img src="/2020/01/19/LeetCode刷题记录-Part1/1.png" alt=""></p>
<p>正如图解所示，第一行为start的排序结果，第二行为end的排序结果。如果下个会以的start大于当前的end，则表示需要第二间会议室来承办下个会议。</p>
<hr>
<h2 id="组合类"><a href="#组合类" class="headerlink" title="组合类"></a>组合类</h2><p><strong>问题描述：</strong>给出一个数组，要求解出所有满足条件的子数组。最典型的例子就是求子集。</p>
<p><strong>解法：</strong>这类题目利用回溯法递归来生成符合条件的子集。根据题目要求判断递归条件即可。</p>
<pre><code>90 Subset II

Given a collection of integers that might contain duplicates, ***nums\***, return all possible subsets (the power set).
</code></pre><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void backtrack(vector&lt;int&gt;&amp; nums, int k, vector&lt;int&gt; subset, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123;</span><br><span class="line">        if (k == nums.size()) &#123;</span><br><span class="line">            res.push_back(subset);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(nums, k+1, subset, res);</span><br><span class="line">        subset.push_back(nums[k]);</span><br><span class="line">        backtrack(nums, k+1, subset, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        backtrack(nums, 0, vector&lt;int&gt; (), res);</span><br><span class="line">        </span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        for (int i = 0; i &lt; res.size(); i++) &#123;</span><br><span class="line">            sort(res[i].begin(), res[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;::iterator iter;</span><br><span class="line">        iter = unique(res.begin(), res.end());</span><br><span class="line">        res.erase(iter, res.end());</span><br><span class="line">        </span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这道题目要求结果中不能包含重复的子集，所以主函数在递归的后面加了筛选条件剔除重复的子集。</p>
<hr>
<h2 id="连续子数组问题"><a href="#连续子数组问题" class="headerlink" title="连续子数组问题"></a>连续子数组问题</h2><p><strong>问题描述：</strong>给出一个数组，求符合条件的最长或者最短连续子数组。</p>
<p><strong>解法：</strong>这类问题使用滑窗法即可。至于什么是滑窗法，见下面这道例题。</p>
<pre><code>239 Sliding Window Maximum

Given an array *nums*, there is a sliding window of size *k* which is moving from the very left of the array to the very right. You can only see the *k* numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
</code></pre><p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3</span><br><span class="line">Output: [3,3,5,5,6,7] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int compare(vector&lt;int&gt;&amp; nums, int i, int j) &#123;</span><br><span class="line">        int max = i;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            if (nums[max] &lt; nums[i+1]) &#123;</span><br><span class="line">                max = i+1;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = k-1;</span><br><span class="line">        while (last &lt; nums.size()) &#123;</span><br><span class="line">            int max = compare(nums, first, last);</span><br><span class="line">            res.push_back(nums[max]);</span><br><span class="line">            first++;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>239中的example很好的解释了什么是滑窗，只不过这道题固定了滑窗的长度。具体解法还是双指针，左指针确定滑窗左值，右指针确定滑窗右值。注意，一般这种要求给出连续数组的题目最好不要使用排序来打乱原始顺序。</p>
<hr>
<h2 id="其他一些分享"><a href="#其他一些分享" class="headerlink" title="其他一些分享"></a>其他一些分享</h2><p>这个模块是分享一些个人觉得很巧妙的解题思路。当然来自LeetCode的Discuss模块。<font color="red"><strong>抄代码不可耻，可耻的是不会抄袭好的代码，更可耻的是不去分析这些代码的逻辑与实现。</strong></font></p>
<p>这道题是求解中位数的一道题，并不怎么难，但是这个人的思路非常巧妙，他使用两个堆，一个大顶堆一个小顶堆，来表示排序后数组。中位数要么是大顶堆的顶值，要么是两个堆顶值的和的一半。</p>
<pre><code>295 Find Median from Data stream

Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
</code></pre><p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4]`, the median is `3</span><br><span class="line">[2,3]`, the median is `(2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3) </span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        if (left.empty() || num &lt;= left.top()) &#123;</span><br><span class="line">            left.push(num);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (left.size() &gt; right.size()+1) &#123;</span><br><span class="line">            int temp = left.top();</span><br><span class="line">            left.pop();</span><br><span class="line">            right.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (left.size() &lt; right.size()) &#123;</span><br><span class="line">            int temp = right.top();</span><br><span class="line">            right.pop();</span><br><span class="line">            left.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        </span><br><span class="line">        double res;</span><br><span class="line">        if (left.size() == right.size()) &#123;</span><br><span class="line">            res = (left.top() + right.top()) / 2.0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = left.top();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    priority_queue&lt;int&gt; left;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码由两部分组成，第一部分是将数组中的元素分别入堆，第二部分是计算中位数的值。</p>
<p>分享的第二道题是昨晚新发现的一种map处理方式。一般我们使用map时，都习惯将key作为序号，value作为保存的值。但是这道题反其道而行之，用key来保存值，value表示序号，即长度。</p>
<pre><code>325 Maximum Size Subarray Sum Equals k

Given an array *nums* and a target value *k*, find the maximum length of a subarray that sums to *k*. If there isn&apos;t one, return 0 instead.
</code></pre><p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, -1, 5, -2, 3], k = 3</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2, -1, 2, 1], k = 1</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: The subarray [-1, 2] sums to 1 and is the longest.</span><br></pre></td></tr></table></figure>
<p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArrayLen(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if (!m.count(sum)) &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum == k) &#123;</span><br><span class="line">                ans = max(ans, i+1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (m.count(sum-k)) &#123;</span><br><span class="line">                ans = max(ans, i-m[sum-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题是让我们求出最长的连续自序列，使该子序列的值等于k。这里我使用哈希表来满足最后的O(n)。key里存储的是当前子序列的和，value储存的是当前连续子序列的长度。该子序列是从数组初始元素开始，每次递加一个长度。然后我们只需要判断当前的和减去给出的k，然后判断这个差是否存在于表里即可。如果存在的话，用当前长度减去差所储存的value值就是当前符合条件的连续子序列长度。</p>
<hr>
<h2 id="建立个人的代码仓库"><a href="#建立个人的代码仓库" class="headerlink" title="建立个人的代码仓库"></a>建立个人的代码仓库</h2><p>这里的代码仓库指的并不是记录你解题的仓库，而是在你刷题过程中，经常使用的或者一些巧妙的算法实现。比如我就把用大顶堆和小顶堆来计算中位数的代码存进了这个仓库。还存储了一些经常使用的操作符重载和一些题目都会用到的模板。这里分享两个。</p>
<p>第一个是对二维vector进行排序的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  static bool compare(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;</span><br><span class="line">​    if (a[0] == b[0]) &#123;</span><br><span class="line">​      return a[1] &lt; b[1];</span><br><span class="line">​    &#125;</span><br><span class="line">​    return a[0] &lt; b[0];</span><br><span class="line">  &#125;</span><br><span class="line">// 调用</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">sort(intervals.begin(), intervals.end(), compare);</span><br></pre></td></tr></table></figure>
<p>第二个是我在做组合问题时总结出来的一个递归模板。等我再遇到组合问题时，直接上代码库中找到这段代码粘贴过去在更改递归判断条件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; main(...)&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;res;  // Store the result, could be other container</span><br><span class="line">    backtrack(res, ...);  // Recursion function to fill the res</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, int cur, ..., vector&lt;int&gt;vec)&#123;</span><br><span class="line">    if(meet the end critria, i.e. cur reach the end of array)&#123;  </span><br><span class="line">        //vec could be a certain path/combination/subset</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Current element is not selected</span><br><span class="line">    backtrack(res, cur+1, ..., vec);</span><br><span class="line">    // Current element is selected</span><br><span class="line">    vec.push_back(cur); // or could be vec.push_back(nums[cur]), vec.push_back(graph[cur]);</span><br><span class="line">    backtrack(res,cur+1, ..., vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>灵活运用你的代码库，并且不断的为其添加复用性高、灵活性高的代码模板，会极大提高刷题效率。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/01/19/LeetCode刷题记录-Part1/">
    <time datetime="2020-01-19T17:12:16.000Z" class="entry-date">
        2020-01-19
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程/">编程</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2020/02/20/HashCode-2020/" rel="prev"><span class="meta-nav">←</span> HashCode 2020</a></span>
    
    
        <span class="nav-next"><a href="/2019/08/13/前方乃是未踏之旅/" rel="next">前方乃是未踏之旅 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LIFE/">LIFE</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC/">MAC</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ML/">ML</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PGM/">PGM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/御宅文化/">御宅文化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">41</span></li></ul>
    </div>
  </aside>

  
    
<div class="widget tag">
<h3 class="title">blogroll</h3>
<ul class="entry">


<li><a href="https://github.com/" target="_blank">我的github</a></li>


<li><a href="http://www.jianshu.com/users/41cd7711ed44/latest_articles" target="_blank">我的简书主页</a></li>


<li><a href="http://uuzdaisuki.com" target="_blank">leticia’s blog</a></li>


<li><a href="http://www.helloyzy.cn" target="_blank">acery</a></li>


<li><a href="http://xjin.wang" target="_blank">WXJACKIE</a></li>


<li><a href="http://www.stephenzhang.me" target="_blank">stephenzhang</a></li>


<li><a href="blog.keybrl.com" target="_blank">keybrl</a></li>


<li><a href="http://blog.ciaran.cn" target="_blank">Ciaran</a></li>


<li><a href="http://1.dev.blog.qinka.pro" target="_blank">Qinka</a></li>


<li><a href="http://tobiasLee.top" target="_blank">TobiasLee</a></li>


<li><a href="http://blog.boileryao.com" target="_blank">bingo</a></li>

</ul>
</div>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/07/05/LeetCode-part3/">LeetCode刷题记录-Part3</a>
          </li>
        
          <li>
            <a href="/2020/04/20/动森大头菜价格分析/">从代码角度分析动森大头菜价格走势</a>
          </li>
        
          <li>
            <a href="/2020/03/15/LeetCode刷题记录-Part2/">LeetCode刷题记录-Part2</a>
          </li>
        
          <li>
            <a href="/2020/02/20/HashCode-2020/">HashCode 2020</a>
          </li>
        
          <li>
            <a href="/2020/01/19/LeetCode刷题记录-Part1/">LeetCode刷题记录-Part1</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud-Computing/">Cloud Computing</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocoapods/">Cocoapods</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab/">Matlab</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Neural-Networks/">Neural Networks</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probabilistic-Graphical-Models/">Probabilistic Graphical Models</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIColor/">UIColor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIView/">UIView</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIView-圆角/">UIView-圆角</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/">Vim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openCV/">openCV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/填坑笔记/">填坑笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/指针/">指针</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 SaberDa
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>